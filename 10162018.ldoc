Hello!

All of our packages are installed. We will NOT be stripping, because it is dangerous. 
We need to log in with a new chroot command, so I will build a new script to do so. This is because the programs in /tools are no longer necessary! So let's get rid of those, eh? (HOW ABOUT A BACKUP FIRST LOL)
I am simply copying the toolchain into a backup directory. That should be fine.
It is quite large, though o.o


Next, we can remove some junk leftover from tests.

rm -rf /tmp/*

We need to remove some static libraries.
rm -f /usr/lib/lib{bfd,opcodes}.a
rm -f /usr/lib/libbz2.a
rm -f /usr/lib/lib{com_err,e2p,ext2fs,ss}.a
rm -f /usr/lib/libltdl.a
rm -f /usr/lib/libfl.a
rm -f /usr/lib/libz.a

In addition, there are a bunch of libtools archive files we don't need, so let's ace those.

find /usr/lib /usr/libexec -name \*.la -delete

So that was some cleanup. Next, we need to learn about system config.

____________________________
|/\/\/\/\/\/\/\/\/\/\/\/\/\|
|        Chapter 7:        |
|   System Configuration   |
|\/\/\/\/\/\/\/\/\/\/\/\/\/|
\__________________________/

( 7.1 ) Booting is difficult, and everythiing has to be done in order and as fast as possible.The boot process that has been used since
you were a baby is called System V, which contains an initialization that sets up necessary programs. It also kicks off a boot-
strapping process run by a script called rc.
Init is controlled by /etc/inittab, and is organized into run levels with different features; usually, full multiuser mode or
full multiuser mode with a display manager are used. To begin, we should install the provided LFS bootscripts. Just extract, and
then make install. A number of helpful programs come along with it.

( 7.3 ) Next, we should talk about device and module handling.
Older linux systems used a static device creation method, wherein thousands of nodes were made with every possible device 
number the heart could desire. It was decided that this was a dumbass idea ( because it was ) and instead, the kernel was
updated to make nodes for devices only when they were detected. This is a decidedly less fucking stupid idea.
A virtual file system called sysfs exists these days to export a view of the system's hardware configuration to user processes.

In order to implement Udev, there are a number of steps we must take. 

I. Sysfs
The sysfs filesystem knows about present devices when modules get loaded or when kernel-compiled objects get registered.
Once sysfs is mounted on /sys, data becomes available to userspace processes and to udevd.

II. Device Node Creation
Device files are created by the kernel. Any driver that wants to register a device node will go through devtmpfs. Afterward, the
kernel sends a uevent to udevd, which creates additional symlinks, permissions, groups, etc. for the device node.

III. Module Loading
Drivers compiled as modules may have aliases built in them. For many devices, the bus driver exports the alias of the driver
that would handle the device via sysfs. The kernel is also able to load modules fo network protocols, filesystems and NLS
support on demand.

IV. Hotplugging & Dynamic Devices
The kernel recognizes when a device is connected and constructs a uevent, which is handled by udevd.




